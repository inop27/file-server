# GIt発展編

## ブランチって何?
- 並行して行われる複数の機能追加やバージョン管理を支援するための機能
  - 複数のメンバーによる機能追加、バグ修正
  - 複数のリリースバージョン
- 履歴の流れを分岐して記録していくためのもの
- 分岐したブランチは他のブランチの影響を受けない
- 分岐したブランチは他のブランチとマージすることで、一つのブランチにまとめなおすことができる
- 並行作業の利点
  - 他のメンバーの作業による影響を受けず、影響を与えない
  - 作業単位で履歴を残すことで、問題が発生した場合に原因となる変更箇所の調査や対策が容易になる
- masterブランチ
  - リポジトリに最初のコミットを行った際に作成されるブランチ。以後のコミットはブランチを切り替えるまでmasterブランチに追加されていく

## ブランチの運用
- ブランチを効果的に利用するには、あらかじめ運用ルールを設けておくことが重要(ここで紹介するルールはあくまでも参考にして、配属先のルールに従う)
- 統合ブランチ
  - リリース版がいつでも作成可能なようにしておくためのブランチ
  - トピックブランチの分岐先としても使用できる(木の幹のようなもの)
  - 安定した状態を保っておく
  - 変更を行う場合は、トピックブランチを作成して作業を行うことが多い
  - Jenkins等のCIツールを使用した自動ビルドやテストはこのブランチを使って行う
  - 通常、masterブランチを統合ブランチとして使用する
- トピックブランチ
  - 機能追加やバグ修正などの課題に関する作業を行うために作成されるブランチ
  - 複数の課題に関する作業を同時に行う時は、その数だけトピックブランチが作成される
  - トピックブランチは安定した統合ブランチから分岐する形で作成し、作業が完了したら統合ブランチに取り込むという使い方をする。

参考画像:
![](https://backlog.com/ja/git-tutorial/assets/img/stepup/stepup2_1.png)

## ブランチの切り替え
- チェックアウト
  - 作業するコミット、ブランチを切り替えるための操作
  - 別のブランチに移動した場合、移動先ブランチ内の最後のコミットの内容がワークツリーに展開される(**要確認**) 
  - チェックアウト後に行ったコミットは、移動後のブランチに対して追加されるようになる(**要確認**)
- HEAD
  - **現在使用しているブランチの先頭を表す名前**
  - デフォルトではmasterの先頭を表している
  - HEADが移動することで、使用するブランチが変更される

- コミットの相対位置指定
  - ~と^を使ってあるコミットからの相対位置で指定する
  - HEAD~nでn世代前の親を指定
  - **^(キャレット)の使い方がよくわからなかったので後で確認**

コンフリクトを起こした場合は、修正してコミットしなおす

## タグ
- コミットを参照するために、分かりやすい名前を付けるもの
- 一度付けたタグは位置が固定される
- 軽量タグ
  - 名前を付けられる
- 注釈付きタグ
  - 名前を付けられる
  - コメントを付けられる
  - 署名を付けられる
- checkout, resetでタグ名を指定して簡単に過去の特定の状態に戻すことができる


一般的なマージとリベースの違い
- マージ
  - 新しくコミットを作りだしてそこで2つのブランチを合流させる
- リベース
  - 新しいコミットを作り出すことはない
  - 誰がリベースしたかがログに記録として残される
  - ログがすっきりする
  - 使い方が直観的ではない
  - 小さなうっかりが取り返しのつかないミスにつながりやすい
  - コンフリクトが発生してしまうと作業が止まってしまい、慣れていないと立ち往生してしまう
  - まだプッシュしていないコミットを整理するために使用するのはOK

似ているコマンドの違い(checkout, reset, revert)
- checkout
  - HEADを移動させる
  - 現在の状態を指定したコミットの状態に戻す
  - ブランチ元の形のままHEADの位置が移動する(ログは変化しない)
- reset
  - HEADとブランチを指定したコミット上に移動させる
  - ログが変化する
- revert
  - 新しくコミットを作り出し、特定のコミットを取り消す
  - ログは変化しない(revert分のびるのみ)

まだマージしていないブランチを削除してしまった場合
- ブランチは付箋のようなもの(このコミットは○○ブランチだよと貼ってあるだけ)
- ブランチを削除しても、コミット自体が消えるわけではない
- 付箋がはがれた位置にもう一度貼りなおせばいい
  - $ git branch ブランチ名 コミットID
  - コミットIDは削除時、またはgit reflog等で探し出す

cherry-pickのつかいどき
- とあるブランチのコミットがほしいが、ブランチ全体をマージしたくはない(同ブランチの他コミットに問題があるなど)場合
- no-commitオプションをつけることで、コピー内容をステージングエリアにおいておくことができる

機密性の高いファイルの扱い
- .gitignoreファイルを作成し、Gitの管理対象外とする

git push -fコマンドについて調べる

作業途中の内容の保存
- 一時的にコミットして別作業後にreset(mixedかな？)をかけて続きにとりかかる
- git stashコマンドを使用する

複数のコミットを一つにマージする
- $ git rebase -i(インタラクティブモード) SHA1

直前に更新したファイル名を取得
- $ git diff-tree HEAD --name-only -r --no-commit-id
- ファイル名だけを羅列
- 階層を全てリストアップ
- $ git archiveでリストアップしたファイルをまとめて圧縮ファイルにする

空のディレクトリをGitの管理下に置きたい場合
- Gitはファイルを監視するので、空のディレクトリは無視される
- .keep1という空のファイルを入れる

プッシュしてエラーが出た場合
- pullしてリモートの最新状態を取り込んでから、問題がないことを確認してpushする

チームメンバーが$ git push -fを実行してしまったら
- 他のメンバーの手元にあるプロジェクトを再度$ git push -fコマンドを実行して被害を覆いつくす
- 復旧作業を終えたら、やらかしたメンバーになぜ$ git push -fコマンドを実行したのか話し合う