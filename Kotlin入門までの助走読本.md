# 1.Kotlinについて知る
## Kotlinとは
- JetBrain社がJavaに代わり、より簡潔に書くことを目的として作った
- JVM(Java仮想マシン)上で動作する
- 静的型付け言語
- JavaScriptへの変換も可能
- Jacaのライブラリを使用することができる
- 既存のJavaプロジェクトでも一部のファイルのみをKotlinで書くことができるため、移行のハードルが低い
- 開発元がIDEも開発している


## Kotlinを使うと何がうれしいのか
- Android開発との親和性の高さ
  - メソッド数が少ない
  - 開発元のIDEサポートがある
  - ライブラリのサイズが小さい
- 生産性の高さ
  - 少ない記述量
    - getter, setterを書く必要がない(もしくは記述量が短縮できる)
    - シングルトン使用が容易
  - コレクション操作などの便利な関数
    - コレクション操作にfor文を使用することはほとんどない
    - ラムダ式にもデフォルトで対応
  - Javaにはない有用な機能
    - 拡張関数
    - 遅延初期化
    - 演算子オーバーロード
    - エルビス演算子
- メンテナビリティの高さ
  - 変数定義時に読み書きの可否、Nullの許容するかなどを定義する必要がある
  - 定義に沿っていない場合、エラーもしくは警告をIDEが出してくれる
  - メンテナビリティの高いコードがかけるように、言語レベルで設計されている


## Kotlinの特徴
- 静的型付けのオブジェクト指向言語
- ターゲットとするプラットフォーム
  - フルスタック(何でもできる)言語を目指して開発されている
  - フロント開発で用いられているnpmやwebpack, react等の使用も可能
- 高階関数をサポート
  - 関数オブジェクトを引数にしたり戻り値にしたりできる
- ラムダ式もサポート
  - 関数を宣言せずに関数オブジェクトをすぐに作成できる
  - 高階関数との併用も可能

## 導入事例
- Flipboard
- Pinterest
- Square Cash
- Expedia


# 2.Kotlinを学ぶ
## 環境構築からHelloWorldまで
- Kotlinを試す方法
  - web上の実行環境である[ページ](https://try.kotlinlang.org/)で試す
    - HelloWorld以外にも有用なサンプルがあるので確認する
  - Android Studio上でKotlin環境を構築して動作させる
    - Android StudioにKotlinプラグインをインストール
    - 新規アプリのプロジェクトを作成
    - JavaのソースコードをKotlinに変換
  - `fun main(args: Araray<String>){}`
  - 戻り値のない場合はUnit型が戻り値となる
  - セミコロンの記述は不要
  - String テンプレート(${変数})

## Kotlinの文法
- 変数の宣言
  - val:再代入不可能
  - var:再代入可能
- 型の省略
  - 変数宣言時に型が推測できる場合、型の宣言を省略できる
- 条件判定(if)
  - 基本はJavaの使い方と同じ
  - if式として使用することもできる
    - `var result : String = if(true) {"true"} else {"false"}`
    - 評価結果を値として受け取るため、if,elseの両方がそろっていないとエラーになる(式ではなく文であると判断される)
- 条件判定(when)
  - Javaでのswich文と同じような構文
  - when式としても使える
  - 条件のうち、必ずどれか一つに一致する必要がある(elseを付けないとエラーになる)
- for文
  ```
  var array: Array<Int> = arrayOf(1, 2, 3, 4, 5)
  for(i in array){
      print(i)
  }
  
  ```
  - for文の形はpython等と同じ
  - arrayOfは標準の関数であり、Array<>型のオブジェクトを作る
  - その他にもコレクション生成関数がある(mapOf, listOf等)
  - Range(0..4のような書き方)も可能
  - downTo関数を使うことで、逆順のループも簡単に実行可能
- while, do-while文
  - Javaと同じ使い方
- Null安全
  - Null非許容型
    - 通常の型はnullの代入を許さない
  - Null許容型
    - 型の後ろに?をつけることでnullを代入できる
  - KotlinでNullPointerExceptionが発生する状況
    - throw等で明示的に発生させる場合
    - !!演算子を使用した場合
  - プログラマーの意図しない箇所でぬるぽが発生することがほぼない
- Nullチェックと安全な呼び出し
  - Null許容型のメソッドやプロパティを参照するとコンパイルエラーとなる(nullが入っている可能性があるため)
    - 事前にifを用いてnull出ないことをチェックする
    - ?演算子を使えば、Null許容型のメソッドやプロパティを参照することができる
      - var l: Int?(bがnullの場合はlもnullとなるため) = b?.length
- エルビス演算子
  - var l: Int = b?.length ?: -1
  - bがnullの場合は-1となり、lの型は**Null非許容型(ここ重要)**であるIntとなる
- !!演算子
  - Null許容型を非許容型に無理やり変換する
  - 使用した変数にnullが入っていた場合は実行時にぬるぽが発生する
  - 非常に危険な操作であるため、一生使わないくらいの気持ちでいるといい
  - どうしてもNull非許容型にしたい場合は、requireNotNullを使用することを検討する
  - この演算子何のために存在してるの？
- 関数
  - 全ての引数は型を明記しないといけない
  - 型推論ができるような戻り値の型であれば、戻り値の型定義を省略することも可能
  - 引数のデフォルト値の定義も可能(型の後ろに=を書く)
  - 名前付き引数は順番を変えても問題なく動く
  - 名前付き引数以降は全て名前付きにする必要がある
  - 名前付き引数は複数の同じ型のメソッドを呼び出す場合などに役に立つ
  - 型パラメータ(ジェネリック型)を使用することもできる
- 高階関数とラムダ式
  - 高階関数
    - 関数オブジェクトを引数にしたり、戻り値にする関数
    - `body: () ->` Tは引数無しで戻り値に任意の型を取る関数を表す
  - ラムダ式
    - 関数を宣言せずに関数オブジェクトをすぐに生成することができる
    - 関数の引数の最後にラムダ式を渡している場合は、引数の外に出して記述することが可能
      - `max(strings) { a, b -> a.length < b.length }`
  - インライン関数
    - 実行時に関数オブジェクトを生成するのはメモリアロケーションコストが高くなる場合がある
    - 実行時ではなく、コンパイル時に関数が展開される
    - inline fun～という形で記述する
- クラス
  - class Myclass{}
  - Javaのようなnewキーワードは不要でインすランス生成可能
  - コンストラクターの記述がなければデフォルトコンストラクターが自動生成される
  - class Person(name: String){}(プライマリーコンストラクター)
    - 処理を記述できない
  - インスタンス生成時に行いたい初期化処理はイニシャライザーに記述する
  - イニシャライザーはinitキーワードで定義する
    - init{処理}
  - コンストラクターを複数定義したい場合はセカンダリーコンストラクターを定義する
    - constructorキーワードを利用して記述する
    - constructor(name: String, parent: Person): this(name){処理}
  - メソッド
    - クラス内に宣言された関数
  - プロパティ
    - var,valキーワードで記述することができる
    - 自動的にパッキングフィールドと呼ばれるものが生成され、実際の値はそこに格納される
      - var,valキーワードでフィールドのように記述するだけで、getter, setter月のフィールドが自動生成される(valは読み取り専用なのでgetterのみ)
      - 自分でgetter, setterを定義することもできる(カスタムゲッター、セッターという)
      - カスタムゲッターを定義した場合はバッキングフィールドは生成されない
    - lateinitキーワード
      - プロパティは必ず初期化する必要がある
      - しかしDI(Dependency Injection)を利用している場合などはインスタンス生成時に値を設定することはできない
      - lateinitキーワードで初期化を遅らせることができる(varの前に付ける)
      - 注意点
        - lateinitはvarでしか利用できないため、初期化後に変更される可能性がある
        - 初期化される前にアクセスすると例外が発生する
  - オブジェクト
    - classの代わりにobjectキーワードを使うことにより、インスタンスが必ず1つしか生成されないシングルトン(デザインパターンの一つで、クラスのインスタンスが1つしか生成されないことを保証する)なクラスを定義できる


# 3.次のステップ