関数
```
fun main(){
    println("Hello World")
}
```

変数宣言
```
val num:Int = 1
#valでの宣言は再代入できない
var num: Int = 1
num = 2(varでの宣言は再代入ok)
```

変数宣言は基本的にvalを使い、再代入が必要ならvarを使うことで不必要にコードを追う手間が省ける。

コンパイル時定数
通常のvalは実行時定数
`const val num: Int = 1`
のようにするとコンパイル時定数になる
コンパイル時定数は以下の要件を満たす
- トップレベルもしくはオブジェクトのメンバー、プリミティブ型、カスタムgetterがない

型推論
宣言した初期値から方が推論できる場合、型注釈の省略ができる。(val num = 1)
ただし方注釈と初期値の両方を省略することはできない

コメント
- 行コメント(//行コメント)
- ブロックコメント(/**/)
- 入れ子

型チェック
if("test" is String){}

文字列
- 埋め込み
  - ${変数}を使って変数の埋め込みができる。
  - 式の結果も埋め込める
  - $変数でも埋め込めるが、半角スペースを空けて変数部分を明確にする必要がある

raw文字列
- 三連引用符(""")で囲むとraw文字列になる
- エスケープ文字列は反映されない
- 改行はそのままされる
- 変数の埋め込みは可能
- 文字列中のインデントを削除するためのメソッドが用意されている

ユニコード
- ユニコードは\uをつける

Nullable(null許容型)
- KotlinではNullPointerExeptionを防ぐため、通常の型ではnullを許可していない
- 型注釈の後ろに?をつけるとnullを許可する(Nullableになる)
- Nullableな変数は.length等でアクセスできない(てぇっくしてからアクセスする必要がある)

?.演算子(セーフコール演算子)
- オブジェクトがnullでない場合はアクセスする演算子
- nullだった場合はnullを返す

!!.演算子
- 強制的にnon-nullに変換する
- ただし、もしnullだった場合はNullPointerExceptionが発生する

?:演算子
- null出なければ左辺の式、nullであれば右辺の式を評価する(s.?.length ?: -1)